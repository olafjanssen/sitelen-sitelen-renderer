<!doctype html>
<html>
    <head>
        <!--<link rel="stylesheet" href="styles/sitelen.css">-->
        <style>
            body {
                font-family: sans-serif;
                text-align: center;
            }

            h1 {
                font-size: 1.5em;
                margin: 0.25em auto;
                display: block;
            }

            .rendered-sitelen,
            .sitelen-sitelen {
                -webkit-writing-mode: vertical-lr;
                writing-mode: vertical-lr;
                text-align: left;
                background: #ddd;
                margin: 1em;
                border: 1px solid #333;
                width: 210mm;
                height: 297mm;
            }

            .rendered-sitelen > svg,
            .sitelen-sitelen > svg {
                width: 40mm;
                padding: 6mm;
            }
        </style>
    </head>
    <body>
        <div class="sitelen-sitelen">
            ale li jo e tenpo. ale li pona. toki pona li toki pona. ante li
            kama. ike li kama. jan li suli mute. mani li suli lili. jan sona li
            jan nasa.
            <!--lupa meli li mama pi ijo ale.-->
            mi pona e ale mi, la mi pona e mi. nasin pona li mute. o olin e jan
            poka. o sona e sina! pali li pana e sona. pilin pona li pana e
            sijelo pona. sina pana e ike, la sina kama jo e ike. wawa li lon
            insa.
            <!--weka lili li pona tawa lawa. wile sona li mute e sona. jan lili li sona ala e ike. -->
            <!--meli li nasa e mije. mi weka e ike jan, la mi weka e ike mi. nasin ante li pona tawa jan ante. telo li pona. lape li-->
            <!--pona. toki li pona. o pana e pona tawa ma. utala li ike.-->
        </div>

        <script type="module">
            import init, {
                render_svg,
                get_layout_ratios,
            } from "../sitelen-sitelen-renderer/sitelen_wasm.js";
            await init();

            ("use strict");

            // Split text into sentences (similar to parser logic)
            function splitIntoSentences(text) {
                // Split on sentence-ending punctuation, but keep the punctuation
                var sentences = [];
                var regex = /([^.!?:#]+[.!?:#])/g;
                var match;
                var lastIndex = 0;

                while ((match = regex.exec(text)) !== null) {
                    var sentence = match[1].trim();
                    if (sentence.length > 0) {
                        sentences.push(sentence);
                    }
                    lastIndex = regex.lastIndex;
                }

                // Handle any remaining text without punctuation
                var remaining = text.substring(lastIndex).trim();
                if (remaining.length > 0) {
                    sentences.push(remaining);
                }

                return sentences;
            }

            function runLayout() {
                [].slice
                    .call(document.querySelectorAll(".sitelen-sitelen"))
                    .forEach(async function (element) {
                        var text = element.textContent
                            .replace(/\s\s+/g, " ")
                            .trim();
                        console.log("Full text:", text);

                        // Split text into sentences
                        var sentences = splitIntoSentences(text);
                        console.log(
                            "Split into",
                            sentences.length,
                            "sentences:",
                            sentences,
                        );

                        // Get available ratios for each sentence
                        var sentenceRatios = [];
                        for (var i = 0; i < sentences.length; i++) {
                            var sentence = sentences[i];
                            var ratiosJson = get_layout_ratios(sentence);
                            var ratios = [];
                            try {
                                ratios = JSON.parse(ratiosJson);
                                if (ratios.length === 0) {
                                    ratios = [1.25]; // Default if no ratios
                                }
                            } catch (e) {
                                console.warn(
                                    "Error parsing ratios for sentence",
                                    i,
                                    ":",
                                    e,
                                );
                                ratios = [1.25]; // Default on error
                            }
                            sentenceRatios.push(ratios);
                            console.log("Sentence", i, "ratios:", ratios);
                        }

                        element.parentNode.removeChild(element);

                        var counter = 0,
                            invCost = 0,
                            prevElement;

                        function renderLoop(frame) {
                            var element = document.createElement("div");
                            element.setAttribute("frame", counter);
                            element.classList.add("rendered-sitelen");
                            document.body.appendChild(element);

                            try {
                                // Render each sentence with a random ratio from its available options
                                var parser = new DOMParser();
                                for (var i = 0; i < sentences.length; i++) {
                                    var sentence = sentences[i];
                                    var ratios = sentenceRatios[i];

                                    // Pick a random ratio for this sentence
                                    var ratio =
                                        ratios.length > 0
                                            ? ratios[
                                                  Math.floor(
                                                      Math.random() *
                                                          ratios.length,
                                                  )
                                              ]
                                            : 1.25;

                                    // Render this sentence
                                    var svgText = render_svg(sentence, ratio);
                                    var doc = parser.parseFromString(
                                        svgText,
                                        "image/svg+xml",
                                    );
                                    var svgEl = document.importNode(
                                        doc.documentElement,
                                        true,
                                    );
                                    element.appendChild(svgEl);
                                }
                            } catch (e) {
                                console.error("Render error:", e);
                                element.parentNode.removeChild(element);
                                if (counter < 100) {
                                    counter++;
                                    requestAnimationFrame(renderLoop);
                                }
                                return;
                            }

                            // compute cost function
                            // With vertical-lr writing mode, SVGs flow top-to-bottom and wrap left-to-right
                            // We need to detect columns based on horizontal position
                            var cost = 0;
                            var pageRect = element.getBoundingClientRect();
                            var svgs = [].slice.call(
                                element.querySelectorAll("svg"),
                            );

                            if (svgs.length === 0) {
                                // No content, skip this frame
                                element.parentNode.removeChild(element);
                                if (counter < 100) {
                                    counter++;
                                    requestAnimationFrame(renderLoop);
                                }
                                return;
                            }

                            // Get positions for all SVGs
                            var svgPositions = svgs.map(function (svg) {
                                var rect = svg.getBoundingClientRect();
                                return {
                                    svg: svg,
                                    left: rect.left,
                                    top: rect.top,
                                    bottom: rect.bottom,
                                    right: rect.right,
                                };
                            });

                            // Sort by top position first, then by left (to process in reading order)
                            svgPositions.sort(function (a, b) {
                                if (Math.abs(a.top - b.top) < 5) {
                                    // Same row, sort by left
                                    return a.left - b.left;
                                }
                                return a.top - b.top;
                            });

                            // Group SVGs into columns based on horizontal position
                            // SVGs in the same column have similar left positions
                            var columnGroups = [];
                            var columnThreshold = 20; // pixels - SVGs within this horizontal distance are in the same column

                            svgPositions.forEach(function (pos) {
                                var placed = false;

                                // Try to find an existing column group for this SVG
                                for (var i = 0; i < columnGroups.length; i++) {
                                    var group = columnGroups[i];
                                    // Check if this SVG's left position matches any SVG in this column
                                    var inColumn = group.some(
                                        function (groupPos) {
                                            return (
                                                Math.abs(
                                                    pos.left - groupPos.left,
                                                ) < columnThreshold
                                            );
                                        },
                                    );

                                    if (inColumn) {
                                        group.push(pos);
                                        placed = true;
                                        break;
                                    }
                                }

                                // If not placed, create a new column
                                if (!placed) {
                                    columnGroups.push([pos]);
                                }
                            });

                            var columns = columnGroups.length;

                            // Calculate cost: sum of unused space at bottom of each column
                            // Lower cost = better packing (less wasted space)
                            columnGroups.forEach(function (column) {
                                // Find the bottom-most SVG in this column
                                var bottomMost = column.reduce(function (
                                    max,
                                    pos,
                                ) {
                                    return pos.bottom > max.bottom ? pos : max;
                                }, column[0]);

                                var unusedSpace =
                                    pageRect.bottom - bottomMost.bottom;
                                if (unusedSpace > 0) {
                                    cost += unusedSpace * unusedSpace; // Square penalty for unused space
                                }
                            });

                            // Avoid division by zero
                            if (cost === 0) {
                                cost = 0.1; // Perfect fit
                            }

                            // Inverse cost: higher is better (more columns, less wasted space)
                            var icost = columns / cost;

                            console.log(counter, invCost, icost, columns, cost);

                            if (icost > invCost) {
                                console.log("newer");
                                invCost = icost;
                                if (prevElement) {
                                    prevElement.parentNode.removeChild(
                                        prevElement,
                                    );
                                }
                                prevElement = element;
                            } else {
                                element.parentNode.removeChild(element);
                            }

                            if (counter < 100) {
                                counter++;
                                requestAnimationFrame(renderLoop);
                            }
                        }

                        requestAnimationFrame(renderLoop);
                    });
            }

            // Run when DOM is ready
            if (document.readyState === "loading") {
                document.addEventListener("DOMContentLoaded", runLayout);
            } else {
                runLayout();
            }
        </script>
    </body>
</html>
